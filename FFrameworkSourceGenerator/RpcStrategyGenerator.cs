using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Xml.Linq;
namespace FFrameworkSourceGenerator
{

    [Generator]
    public class RpcStrategyGenerator : ISourceGenerator
    {
        const string generatedFileName = "FRpcStrategyAdapter.cs";
        const string namespaceName = "FFramework.Rpc";
        const string className = "FRpcStrategyAdapter";
        const string methodName = "ApplyStrategy";
        const string methodP1 = "eventId";
        const string methodP2 = "pData";
        const string rpcEventAttributeName = "FRpcEventAttribute";

        public void Execute(GeneratorExecutionContext context)
        {

            if (context.Compilation.AssemblyName != "Assembly-CSharp") return;
            //当前编译任务
            Compilation compilation = context.Compilation;



            //生成using语句定义
            CompilationUnitSyntax compilationUnitSyntax = SyntaxFactory.CompilationUnit()
            .WithLeadingTrivia(SyntaxFactory.Space)
            .WithTrailingTrivia(SyntaxFactory.Space)
            .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")))
            .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Collections.Generic")))
            .WithLeadingTrivia(SyntaxFactory.TriviaList(SyntaxFactory.Comment("//Code Generated By FFramework\n")));



            //生成命名空间定义
            NamespaceDeclarationSyntax namespaceSyntax =
                SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(namespaceName));


            //生成静态策略类定义
            ClassDeclarationSyntax classSyntax = SyntaxFactory.ClassDeclaration(className)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword));

            //生成策略方法签名定义
            MethodDeclarationSyntax methodSyntax = SyntaxFactory.MethodDeclaration(
                //返回值类型 ，方法名
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword)), methodName)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                //参数列表
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier(methodP1)).WithType(SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.LongKeyword))),
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier(methodP2)).WithType(SyntaxFactory.ParseTypeName("ReadOnlySpan<byte>"))
            );


            //生成策略预处理代码定义
            //StatementSyntax preProcess =
            //    SyntaxFactory.ExpressionStatement(
            //        SyntaxFactory.ParseExpression($""
            //    ));


            //策略default处理代码定义
            StatementSyntax defaultCaseProcess =
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.ParseExpression($"break"
                ));


            //策略代码 switch块定义
            SwitchStatementSyntax switchSyntax =
                //switch(eventId)
                SyntaxFactory.SwitchStatement(
                    SyntaxFactory.IdentifierName(methodP1),
                    SyntaxFactory.SingletonList<SwitchSectionSyntax>(
                        SyntaxFactory.SwitchSection(
                            //default: ...break;
                            SyntaxFactory.SingletonList<SwitchLabelSyntax>(
                                SyntaxFactory.DefaultSwitchLabel()),
                            SyntaxFactory.SingletonList<StatementSyntax>(
                                defaultCaseProcess
            ))));

            // 获取所有语法树
            var syntaxTrees = compilation.SyntaxTrees;

            var sha256 = SHA256.Create();

            //生成策略case定义
            foreach (var syntaxTree in syntaxTrees)
            {

                // 获取语法树的根节点
                var root = syntaxTree.GetRoot();

                // 使用语法树的根节点来获取所有接口类型
                var interfaces = root.DescendantNodes().OfType<InterfaceDeclarationSyntax>();

                foreach (var interfaceSyntax in interfaces)
                {
                    try
                    {
                        var semanticModel = context.Compilation.GetSemanticModel(interfaceSyntax.SyntaxTree);
                        INamedTypeSymbol interfaceSymbol = semanticModel.GetDeclaredSymbol(interfaceSyntax);
                        if (interfaceSymbol == null) continue;
                        string interfaceName = interfaceSymbol.ToDisplayString();

                        //取得接口特性表
                        var interfaceAttributes = semanticModel.GetDeclaredSymbol(interfaceSyntax)
                            ?.GetAttributes()
                            .Select(attributeData => attributeData.AttributeClass)
                            .OfType<ITypeSymbol>();

                        // 判断接口是否带有 FRpcEvent 特性
                        if (interfaceAttributes.Any(attribute => attribute.Name == rpcEventAttributeName))
                        {
                            //根据接口限定名称计算 Hash-64
                            long hashValue = BitConverter.ToInt64(sha256.ComputeHash(Encoding.UTF8.GetBytes(interfaceName)), 0); ;
                            if(interfaceSymbol?.Interfaces.Length!=1)
                            {
                                throw new InvalidOperationException("FRpcEvent can only and must be derived from a single event interface, and is not allowed to be derived from multiple interfaces");
                            }
                            //获取其第一个父接口
                            INamedTypeSymbol parentInterfaceSymbol = interfaceSymbol?.Interfaces.FirstOrDefault();
                            //父接口泛型参数类型表
                            var genericArguments = parentInterfaceSymbol?.TypeArguments;

                            //泛型参数数量
                            int argumentCount = 0;
                            //泛型定义构建字符串
                            StringBuilder builder = new StringBuilder();
                            if (genericArguments != null)
                            {
                                foreach (var genericArgumentType in genericArguments)
                                {
                                    argumentCount++;
                                    builder.Append(genericArgumentType.ToDisplayString());
                                    builder.Append(',');
                                }
                            }
                          

                            //int,string,....
                            string packType = argumentCount != 0 ? $"FFramework.Rpc.RpcPack<{builder.ToString().TrimEnd(',')}>" :
                                $"FFramework.Rpc.RpcPack";

                            //参数转换列表
                            var statements = new List<StatementSyntax>();

                            //反序列化为RpcPack类型
                            statements.Add(SyntaxFactory.ExpressionStatement(
                                      SyntaxFactory.ParseExpression($"{packType} _pack = global::MemoryPack.MemoryPackSerializer.Deserialize<{packType}>(pData)"))
                               );

                            //序列化参数调用    _pack.a,_pack.b, _pack.c...
                            StringBuilder a_zOrder = new StringBuilder();
                            for (int i = 0; i < argumentCount; i++)
                            {
                                a_zOrder.Append("_pack");
                                a_zOrder.Append('.');
                                a_zOrder.Append((char)('a' + i));
                                a_zOrder.Append(',');
                            }
                            string a_zP = a_zOrder.ToString().TrimEnd(',');

                            //throw new Exception($"global::FFramework.FEvent.Instance.Operator<{interfaceName}>().Send({a_zP})");
                            statements.Add(SyntaxFactory.ExpressionStatement(
                                      SyntaxFactory.ParseExpression($"global::FFramework.FEvent.Instance.Operator<{interfaceName}>().Send({a_zP})")));
                            statements.Add(SyntaxFactory.BreakStatement());


                            switchSyntax = switchSyntax.AddSections(
                                SyntaxFactory.SwitchSection(
                                    SyntaxFactory.SingletonList<SwitchLabelSyntax>(
                                        SyntaxFactory.CaseSwitchLabel(
                                            SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(hashValue))
                                         )
                                        .WithLeadingTrivia(SyntaxFactory.Comment($"// Hash64 => {interfaceName} : {parentInterfaceSymbol.ToDisplayString()}"))
                                    ),
                                    SyntaxFactory.List<StatementSyntax>(
                                         SyntaxFactory.SingletonList<StatementSyntax>(SyntaxFactory.Block(statements))
                                        )));
                        }
                    }
                    catch (Exception e)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                                new DiagnosticDescriptor("GEN001", "Error", e.ToString(), "Generator", DiagnosticSeverity.Error, true),
                                interfaceSyntax.GetLocation()
                               ));
                    }
                }
            }


            methodSyntax = methodSyntax.AddBodyStatements(/*preProcess,*/ switchSyntax);
            classSyntax = classSyntax.AddMembers(methodSyntax);
            namespaceSyntax = namespaceSyntax.AddMembers(classSyntax);
            compilationUnitSyntax = compilationUnitSyntax.AddMembers(namespaceSyntax).WithTrailingTrivia(SyntaxFactory.ElasticSpace);
            //转CSharp源代码字符串
            string generatedCode = compilationUnitSyntax.NormalizeWhitespace().ToFullString();
            //生成到文件
            context.AddSource(generatedFileName, SourceText.From(generatedCode, System.Text.Encoding.UTF8));
        }


        public void Initialize(GeneratorInitializationContext context)
        {

        }

    }

}
